# About
This repo contains the relevant (for me) C++ related learning materials. <br>
The notes and codes are for my own reference. I strongly sense that they would not make much sense without going through the information sources (e.g. book sections).

### Sections

#### preliminary:
[Programming Abstractions with C++](https://web.stanford.edu/dept/cs_edu/resources/textbook/) (by [Eric S. Roberts](https://cs.stanford.edu/people/eroberts/)) is the book which this section is based upon. 

Paused at page 823 (839) - Inheritance;
Revisiting & paused at page 804 (820) - finding shortest path (in a graphs)<br>

Skipped sections (and some notes) worth re-exploring:
- Exercises in each chapter
- Graphics related demos on chapter 2
- Vector class demos on chapter 5.1
  - ways of declaring vectors:
    - Vector&lt;type> vec;
    - Vector&lt;type> vec(size);
    - Vector&lt;type> vec = { x1, x2, x3 };
    - Vector&lt; Vector&lt;type> > vec(size, Vector&lt;type>(size));
      - notice the required space separating the inner & outer angle brackets
- Stack class demos on chapter 5.2
  - including RPN Calculator
- Particular step in queue demo (CheckoutLine.cpp)
  - applying Queue class provided from the more convenient nonstandard library
- Map, Set & Lexicon classes demos on chapter 5.4 & 5.5
- Rational class interface & implementation codes on chapter 6.3, pg 288-291
- Chapters 7 until 10
  - programming concepts not specific to C++
    - recursion
    - recursive strategies
    - backtracking algorithms
    - algorithmic analysis
- Try out stack-heap diagram drawing, Chapter 12.5, page 538 (554)
- Write code for the Map template class (not in book)
- Implementing AVL tree insertion algorithm
- Exercises on chapter 17
  - especially using bitwise operations in implementing character vectors
- Graph-related codes on chapter 18

!!!!! (some notes, concepts and terms):
- reference parameters e.g. "& a" (in Quadratic.cpp)
- first use of cerr in Quadratic.cpp, made to a library w/ interface (error.cpp & error.h respectively)
- interfaces (a.k.a abstraction boundary) should be
  - unified - if some function doesn't fit the interface theme, put it elsewhere. also, ensure consistency e.g. use degrees only or radians only
  - simple - hide complexity (e.g. in implementation) from client, even in the commentary; contain only what client needs to know
  - sufficient - must provide sufficient functionality to meet clients' needs
  - general - flexible as to be usable by many different clients; inclusion of functionality should not be based on percieved importance
  - stable - no breaking changes
- parameterized classes a.k.a. templates: classes that include a base-type specification. E.g. Vector e.g. Vector&lt;char>, Vector&lt;int>, etc.
- bounds-checking: testing whether an index is valid
- on declaration of primitive variables (without explicit initialization), the memory used to hold the variables still holds the value it has before the declaration
- on declaration of classes, the case is different due to constructors being invoked, which leads to initializations.
- associative arrays: arrays implemented using maps as their underlying representation
- range-based for loops can be used in conjunction with Vector, Grid, Map, Set, Lexicon but NOT Stack nor Queue (as unrestricted access to these structures would violate the "*only one element visible at one time*" principle)
- several advantages of Abstract Data Types over primitive types:
  - simplicity
  - flexibility
  - security
- two ways of overloading binary operators in C++ for a newly defined class:
  - method within the class
    - left operand is the receiver object
    - right operand is passed as a parameter
      - bool operator==(Point pt);
  - free function outside the class
    - both operands are passed as parameters
      - bool operator==(Point pt1, Point pt2);
  - special note:
    - access to private instance variables can be made legal for a particular function by declaring the function as a *friend*
      - friend bool operator==(Point pt1, Point pt2);
    - ...which is applicable to classes as well
      - friend class *name*;
- author's approach to designing classes:
  - 1) Think generally about how clients are likely to use the class
    - Design it around their convenience (not the implementer's)
  - 2) Determine (intuitively, generally) what information belongs in the private state of each object
  - 3) Define a set of constructors
    - and perhaps consider whether the constructors need to apply any restriction to ensure resulting objects' validity
  - 4) Enumerate the operations that will become the public method
    - i.e. specify and write the prototypes
    - rememember the principles of unity, simplicity, sufficiency, generality, and stability
  - 5) Code and test the implementation
    - Once the interface is done, write the code that implements it
    - Revisit the interface design if needed to ensure features perform to acceptable levels of efficiency
- When using a class as a client (as opposed to as an implementor), it would make sense to ignore the private section of a class, even though C++ requires that the private section be included in the interface
- tokens: logical units of a string that may be larger than a single character
- sometimes i.e. when some amount of internal state needs to be maintained, it may be appropriate to encapsulate the entire program inside a class (e.g. demo in [CheckoutLineClass.cpp](https://github.com/wafibismail/exploring-cpp/blob/main/preliminary/CheckoutLineClass.cpp))
  - in which case, the main program creates a variable of that class and invokes a method in that class to get the program running
- C++ defines the data type char to be exactly one byte in size (ASCII)
  - use the type wchar_t (wide characters) for programs that work with expanded charcter sets
- in C++, the size of an object is the sum of the sizes of the instance variables it contains
  - note though that compilers are allowed to add memory space to the underlying representations of an object as doing so sometimes allows for a more efficeint machine language code.
    - e.g. the size of a Point object (with two int instance variables) must be at least eight bits, though it might be larger
- sizeof:
  - sizeof(int) returns the number of bytes required to store a value of type int
  - sizeof x returns the number of bytes required to store the variable x
- array
  - in most cases, array size declarations should be specified as symbolic constants e.g.
    - const int N_ELEMENTS = 10; // and use this in square brackets in the array's declaration
  - selection: the process of identifying a particular element in an array
  - number of elements = sizeof ARR / sizeof ARR[0];
    - use this for statically declared arrays only
    - for dynamic arrays, better to set size of array as the approximate maximum number of elements (allocated size) i.e. larger than needed - then use only part of it
      - with this method, a separate int variable keeping track of the number of values that are in use (effective size)
- freeing memory
  - delete ip;
  - delete[] array;
  - *if it's a linked list, delete recursively*
- on choosing an implementation strategy w/ regard to efficiency
  - *"One way to ensure that there are no hidden costs is to limit the implementation so that it relies only on the most primitive operations supported by the language"*
    - example demonstrating this in CharStack implementation
      - primitive array used as opposed to some abstract class e.g. Vector
- if stuck in debugging as far as memory allocation is concerned, consider drawing heap-stack diagrams
  - refer to page 538 (554)
- unit testing: strategy of checking each class or interface separately in isolation from any other module
  - can use &lt;cassert> library
    - assert(*test*)
      - as long as the test expression evaluates to true, the assert macro has no effect
      - else an error message is generated
  - refer to [CharStackUnitTest.cpp](https://github.com/wafibismail/exploring-cpp/blob/main/preliminary/CharStackUnitTest.cpp))
- constant call by reference e.g:
  - void deepCopy(const CharStack & src)
    - guarantees that the function e.g. deepCopy will not change the value of src even though it is passed by reference
- if you allocate dynamic memory as part of a class, you have a responsibility to redefine the copy constructor and the assignment operator
  - e.g. redefine them to either:
    - perform a deep copy (e.g. in [CharStack](https://github.com/wafibismail/exploring-cpp/blob/main/preliminary/charstack.cpp)), or
    - perform nothing i.e. make copying illegal (e.g. in [EditorBuffer](https://github.com/wafibismail/exploring-cpp/blob/main/preliminary/buffer.h))
  - if this is skipped, the compiler will automatically define versions of those methods that do the wrong thing
- Computational complexity of three buffer models, + DLList
  - Array | Stack | List ||| DLList : operation
  - O(1) | O(1) | O(1) ||| O(1) : moveCursorForward
  - O(1) | O(1) | O(N) ||| O(1) : moveCursorBackward
  - O(1) | O(N) | O(1) ||| O(1) : moveCursorToStart
  - O(1) | O(N) | O(N) ||| O(1) : moveCursorToEnd
  - O(N) | O(1) | O(1) ||| O(1) : insertElement
  - O(N) | O(1) | O(1) ||| O(1) : deleteElement
    - with DLList, time may be saved, but more space is consumed for storing each element's backward link
    - consider the more suitable combination of array and DLList for potential use in the class [EditorBuffer](https://github.com/wafibismail/exploring-cpp/blob/main/preliminary/buffer.cpp):
      - DLList representing the buffer containing individual lines
        - DLList storage overhead significant reduced as links are used on each line only as opposed to on each element
      - array representing each line containing individual characters
        - slow in insertion at the beginning of a line but only proportional to the line, not whole buffer
- If inserting and deleting from a linked list, allocating an extra dummy cell may often be convenient
- templates : when exported, we must make the implementation available to the compiler when the .h file is read
  - this means the .h file has to include the implementation
    - the client SHOULD NOT have to look at the code beyond the interface i.e. (the implementation)
- in the book, Stack ADT is represented in:
  - array
  - list (code in my repo is for this one only)
- in the book, Queue ADT is represented in:
  - array / ring buffer
    - keeping track of both head and tail to avoid having to shift elements
- by convention, an empty tree's height is defined to be -1
- the AVL algorithm (for maintaining trees' balance) is used in the book as it's easy to understand, though it is by no means the most efficient.
  - with AVL trees, balance after insertion can always be restored by performing one operation i.e. either:
    - single rotation
    - double rotation
- traversing / walking a binary tree: to step through its nodes
  - preorder traversal: when the key in each node is processed before the recursive calls to process the subtrees
  - postorder traversal: processing each node after both recursive calls
  - inorder traversal: processing the current node between the two recursive calls
- two fundamental traversal strategies for graphs:
  - depth first search - explore a single path in the graph as far as possible before backtracking to complete exploration of paths at higher levels
  - breadth first search - visit starting node first, then nodes one hop away, followed by nodes that are two hops away, and so on